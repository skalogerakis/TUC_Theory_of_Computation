Terminals unused in grammar

   TK_IDENT
   TK_STRING
   KW_INT
   KW_REAL
   KW_BOOL
   KW_STRING
   KW_TRUE
   KW_FALSE
   KW_IF
   KW_THEN
   KW_ELSE
   KW_FI
   KW_WHILE
   KW_LOOP
   KW_POOL
   KW_CONST
   KW_LET
   KW_RETURN
   KW_AND
   KW_OR
   KW_START
   KW_NOT
   OP_MINUS
   OP_MUL
   OP_DIV
   OP_MOD
   OP_EQUALS
   OP_NOT_EQUALS
   OP_SMALLER
   OP_SMALLER_EQUALS
   OP_ASSIGN
   OP_ARROW
   DEL_LEFT_PARENTESIS
   DEL_RIGHT_PARENTESIS
   DEL_COMMA
   DEL_LEFT_BRACKETS
   DEL_RIGHT_BRACKETS
   DEL_COLON
   DEL_LEFT_CURLY_BRACKETS
   DEL_RIGHT_CURLY_BRACKETS


Grammar

    0 $accept: input $end

    1 input: %empty
    2      | input expr DEL_SEMICOLON

    3 expr: TK_INT
    4     | TK_REAL
    5     | expr OP_PLUS expr


Terminals, with rules where they appear

$end (0) 0
error (256)
TK_IDENT (258)
TK_INT (259) 3
TK_REAL (260) 4
TK_STRING (261)
KW_INT (262)
KW_REAL (263)
KW_BOOL (264)
KW_STRING (265)
KW_TRUE (266)
KW_FALSE (267)
KW_IF (268)
KW_THEN (269)
KW_ELSE (270)
KW_FI (271)
KW_WHILE (272)
KW_LOOP (273)
KW_POOL (274)
KW_CONST (275)
KW_LET (276)
KW_RETURN (277)
KW_AND (278)
KW_OR (279)
KW_START (280)
KW_NOT (281)
OP_PLUS (282) 5
OP_MINUS (283)
OP_MUL (284)
OP_DIV (285)
OP_MOD (286)
OP_EQUALS (287)
OP_NOT_EQUALS (288)
OP_SMALLER (289)
OP_SMALLER_EQUALS (290)
OP_ASSIGN (291)
OP_ARROW (292)
DEL_SEMICOLON (293) 2
DEL_LEFT_PARENTESIS (294)
DEL_RIGHT_PARENTESIS (295)
DEL_COMMA (296)
DEL_LEFT_BRACKETS (297)
DEL_RIGHT_BRACKETS (298)
DEL_COLON (299)
DEL_LEFT_CURLY_BRACKETS (300)
DEL_RIGHT_CURLY_BRACKETS (301)


Nonterminals, with rules where they appear

$accept (47)
    on left: 0
input (48)
    on left: 1 2, on right: 0 2
expr (49)
    on left: 3 4 5, on right: 2 5


State 0

    0 $accept: . input $end
    1 input: . %empty
    2      | . input expr DEL_SEMICOLON

    $default  reduce using rule 1 (input)

    input  go to state 1


State 1

    0 $accept: input . $end
    2 input: input . expr DEL_SEMICOLON
    3 expr: . TK_INT
    4     | . TK_REAL
    5     | . expr OP_PLUS expr

    $end     shift, and go to state 2
    TK_INT   shift, and go to state 3
    TK_REAL  shift, and go to state 4

    expr  go to state 5


State 2

    0 $accept: input $end .

    $default  accept


State 3

    3 expr: TK_INT .

    $default  reduce using rule 3 (expr)


State 4

    4 expr: TK_REAL .

    $default  reduce using rule 4 (expr)


State 5

    2 input: input expr . DEL_SEMICOLON
    5 expr: expr . OP_PLUS expr

    OP_PLUS        shift, and go to state 6
    DEL_SEMICOLON  shift, and go to state 7


State 6

    3 expr: . TK_INT
    4     | . TK_REAL
    5     | . expr OP_PLUS expr
    5     | expr OP_PLUS . expr

    TK_INT   shift, and go to state 3
    TK_REAL  shift, and go to state 4

    expr  go to state 8


State 7

    2 input: input expr DEL_SEMICOLON .

    $default  reduce using rule 2 (input)


State 8

    5 expr: expr . OP_PLUS expr
    5     | expr OP_PLUS expr .  [OP_PLUS, DEL_SEMICOLON]

    $default  reduce using rule 5 (expr)

    Conflict between rule 5 and token OP_PLUS resolved as reduce (%left OP_PLUS).
